---
author: Flavio Copes
date: "2024-12-21T15:13:26Z"
identifier: "urn:uuid:3280f88b-716d-48a9-808f-86401eeb6b17"
language: en-US
title: Git 速查手册
---


## 前言 

欢迎来到 Git 速查手册，这是一个深入的指南，旨在为初学者和经验丰富的开发者提供使用 Git 所需的知识，Git 是软件行业中最受欢迎的版本控制系统。无论您是在管理一个独立项目还是在一个大型团队中协作工作，这本速查手册都旨在成为您不可或缺的资源。通过提供清晰的解释和实用的示例，旨在解开 Git 的复杂性，并将其转化为直观且可操作的见解。

在本指南中，您将探索形成软件版本控制基础的广泛 Git 命令和概念。从初始化存储库和提交更改等基本操作，到分支、合并和变基等高级技术，本速查手册应有尽有。您还将深入了解如合并提交、二分调试、处理子模块和实现子树等专业主题，确保您有充分的准备来应对开发过程中可能遇到的任何挑战。

随着您的进展，您将学习如何维护数据完整性、管理多个工作树，并有效地解决合并冲突。每个章节都结构化地提供分步指导，使您能够立即在项目中应用所学。到旅程结束时，您将不仅对 Git 有更深入的理解，还将有信心使用它来简化您的工作流程，增强与同事的协作。

为了充分利用本速查手册，建议读者具备命令行操作和一般编程原则的基础知识。熟悉使用终端或命令提示符将显着有助于理解和应用提供的示例。此外，掌握版本控制概念的基础知识将增强您有效导航此指南的能力。

> 作者： Flavio
> 
> 翻译：南川
> 
> 编辑：南川
> 
> Powered by ai-markdown-translator & ChatGPT.


---

```insta-toc
---
title:
  name: 本文目录：
  level: 1
  center: false
exclude: ""
style:
  listType: dash
omit: []
levels:
  min: 1
  max: 2
---

# 本文目录：

- 前言
- 01. 基本 Git 命令
- 02. 工作目录和暂存区
- 03. 分支操作
- 04. 合并
- 05. 远程
- 06. 修改提交
- 07. 临时储藏
- 08. 标记
- 09. 还原更改
- 10. 查看历史日志
- 11. 不同版本间的差异
- 12. Git Flow
- 13. 探索 Git 引用
- 14. 配置
- 15. 安全
- 16. 设置别名
- 17. 变基
- 18. 选择性提取（Cherry-Picking）
- 19. 补丁
- 20. 相对日期
- 21. 注释（Blaming）
- 22. 归档
- 23. 跟踪
- 24. 索引操作
- 25. 合并提交
- 26. 数据完整性
- 27. 清理
- 28. 子树
- 29. 搜索
- 30. 二分查找
- 31. 属性
- 32. 检出
- 33. 引用日志（Reflog）
- 34. 处理未跟踪文件
- 35. 强制推送
- 36. 获取与拉取
- 37. 处理合并冲突
- 38. 工作树
- 39. 子模块
- 写在最后
```


## 01. 基本 Git 命令 

在本节中，我们深入探讨作为有效管理和导航 Git 存储库的构建块的基本 Git 命令。Git 是一个分布式版本控制系统，对于跟踪代码库变化、与其他开发人员协作以及维护项目历史的完整性是必不可少的。理解这些基本命令对于任何希望在开发工作流中充分利用 Git 的人来说至关重要。

我们将探讨一系列覆盖 Git 使用关键方面的命令，例如初始化新存储库、提交更改、分支和合并。每个命令都用简短的句子解释其目的，并通过实际例子说明如何在现实场景中有效使用。无论您是在设置一个新项目还是在已有代码库上进行工作，这些命令将帮助您组织工作并保持流畅的工作流程。

#### `git help`

`git help` 命令打印 Git 帮助信息。它提供了对 Git 基本用法和最常用 Git 命令的快速参考。当您需要快速提醒 Git 功能或想要探索可用命令时，此命令非常有用。

您还可以使用 `git help <command>` 来显示任何特定 Git 命令的帮助信息。例如，`git help git` 将具体打印 Git 命令本身的帮助。

这些帮助命令是初学者和经验丰富用户快速访问有关 Git 功能和用法信息的宝贵资源。

#### `git version`

`git version` 命令显示您系统上安装的 Git 的版本。此命令对于验证您当前使用的 Git 版本非常有用，这对于某些功能的兼容性或在故障排除时可能很重要。

#### `git init`

`git init` 命令用于在当前目录中初始化一个新的 Git 存储库。此命令创建一个名为 `.git` 的新子目录，包含新存储库所需的所有元数据。它通常是您在启动一个希望使用 Git 管理的项目时运行的第一个命令。运行此命令后，您可以开始跟踪文件并在新的 Git 存储库中进行提交。

#### `git clone <repository_url>`

`git clone <repository_url>` 命令在您的本地计算机上创建一个远程 Git 存储库的副本。它下载所有文件、分支和提交历史，使您能够立即开始处理项目。

#### `git status`

`git status` 命令显示 Git 存储库的工作目录和暂存区的当前状态。它显示有关哪些文件已被修改、添加或删除的信息，以及这些更改是否已暂存以供下次提交。

## 02. 工作目录和暂存区

工作目录和暂存区是 Git 中在版本控制过程中发挥关键作用的基本概念。工作目录是您主动对文件进行更改的环境，代表项目的当前状态。本质上，它是一个沙箱，您可以在其中自由编辑、删除和创建文件以开发项目。然而，这些更改是您机器本地的，并尚未成为版本历史的一部分。

另一方面，暂存区，也称为索引，充当工作目录和存储库之间的中介空间。它充当检查点，您可以在提交到存储库历史之前，有选择地组织更改。这使您能够准备一组逻辑相关的更改，确保每个提交都有意义且一致。

下面的命令将促进在工作目录和暂存区之间管理更改。它们允许您将文件添加到暂存区，移除它们，或修改现有文件，使您可以控制将在下次提交中包含的内容。通过使用这些命令，您可以确保仅提交预期的更新，使项目历史简洁且有序。该过程对于保持清晰和易于理解的历史记录至关重要，因为它使您能够精准明确地追踪项目的发展。

#### `git checkout .`

`git checkout .` 命令放弃工作目录中的所有更改，将文件恢复到其最后提交的状态。此命令对于快速撤销本地修改并将工作目录恢复到干净状态非常有用。

#### `git reset -p`

`git reset -p` 命令允许您交互式地重置工作目录中的更改。它提供了一种选择性撤销修改的方法，使您可以精细地控制保留或放弃哪些更改。

#### `git add <file>`

`git add <file>` 命令将特定文件添加到 Git 中的暂存区。这为包含在下次提交中的文件进行准备，允许您有选择地选择在版本历史中包括哪些更改。

#### `git add -p`

允许您通过分块（hunks）交互式地从工作目录中暂存更改，使您能够在提交之前查看并有选择地将部分更改添加到索引。

#### `git add -i`

进入添加文件的交互模式。提供一个基于文本的交互菜单，您可以在其中选择要执行的各种操作，例如暂存单个更改、更新文件或查看状态。

#### `git rm <file>`

从工作目录中移除一个文件并暂存该移除操作。

#### `git rm --cached <file>`

从暂存区（索引）中移除指定文件，但在您的工作目录中保留该文件，从而有效地取消对该文件的版本控制。

#### `git mv <old_path> <new_path>`

`git mv <old_path> <new_path>` 命令用于在 Git 存储库中移动或重命名一个文件或目录。它会自动暂存更改，使其为下次提交做好准备。

#### `git commit -m "message"`

`git commit -m "message"` 命令用于在 Git 存储库中创建一个新的提交。它会保存已暂存的更改（添加到索引）并附带描述性信息。该消息应简要说明此次提交中所做的更改。

## 03. 分支操作

Git 分支是 Git 存储库中的并行开发线，允许您在不影响主代码库的情况下独立地处理不同的功能、错误修复或实验。每个分支可以有自己的提交历史，在合并之前，在一个分支上进行的更改不会影响其他分支。这有助于组织工作，并通过使多个开发人员能够同时处理项目的不同方面而不干扰彼此的进展来促进协作。

在本节中，我们将介绍一些命令，这些命令允许您在您的 Git 存储库中创建、切换、列出、重命名和删除分支。这些命令有助于管理并行开发线，使您能够独立于工作焦点或错误修复进行工作。您还将了解到如何显示提交历史和分支关系，以及如何管理远程分支。

#### `git branch <branch_name>`

创建一个新分支。

#### `git checkout <branch_name>`

切换到指定分支并更新工作目录。

#### `git branch`

列出所有分支。

#### `git branch -d <branch_name>`

删除一个分支。

#### `git push --delete <remote> <branch>`

删除远程分支。

#### `git branch -m <old_name> <new_name>`

重命名一个分支。

#### `git checkout -b <new_branch>`

基于当前分支创建并切换到一个名为 `<new_branch>` 的新分支。

#### `git switch <branch>`

切换工作目录到指定分支。

#### `git show-branch <branch>`

显示所有或选定分支的提交历史和分支关系总结，展示每个分支的分歧点。

#### `git show-branch --all`

与上述功能相同，但适用于所有分支及其提交。

#### `git branch -r`

列出本地存储库知道的所有远程分支。

#### `git branch -a`

列出存储库中的所有分支，包括本地和远程分支（本地存储库知道的部分）。

#### `git branch --merged`

列出已完全合并到当前分支的所有分支，如果不再需要，可安全删除。

#### `git branch --no-merged`

列出尚未完全合并到当前分支的所有分支，显示尚未集成的更改。

## 04. 合并

git merge 命令用于将一个分支的更改合并到另一个分支。它集成了两个分支的历史，创建一个包含两个来源更改的新提交。此过程允许多个开发线汇聚在一起，促进协作并确保所有更新都整合到主项目中。合并期间，如果更改重叠，则可能会发生冲突，需要手动解决以确保最终结果一致。

#### `git merge <branch>`

将指定分支的更改集成到当前分支中，结合它们的历史。

#### `git merge --no-ff <branch>`

合并指定分支到当前分支，即使可以快进合并也总是创建一个新的合并提交。

#### `git merge --squash <branch>`

将指定分支的所有更改合并到一个提交中，准备更改在当前分支中提交而不合并该分支的历史，允许您手动编辑提交消息。

#### `git merge --abort`

取消正在进行的合并过程，并恢复工作目录和索引到合并开始之前的状态。

#### `git merge -s ours <branch>`

使用 "ours" 策略进行合并，保留当前分支的更改并舍弃指定分支的更改，有效地合并历史而不集成其他分支的更改。

#### `git merge --strategy=theirs <branch>`

使用 "theirs" 策略将指定分支合并到当前分支，解决所有冲突时优先于被合并分支的更改（注意："theirs" 策略不是内置策略，通常需要自定义脚本或用于解决冲突的工具）。

## 05. 远程

Git 远程是指对远程存储库的引用，这些存储库是托管在互联网或其他网络上的项目版本。它们通过允许多个用户与中央存储库共享和同步更改来实现协作。远程操作的常见操作包括 git fetch 用于检索更新，git pull 用于获取和合并更改，以及 git push 用于将本地提交上传到远程存储库。管理远程包括添加、删除和重命名远程连接以及配置 URL 以实现无缝协作。

#### `git fetch`

从远程存储库获取更改，但不将其合并到当前分支。

#### `git pull`

从远程存储库获取更改并立即合并到当前分支。

#### `git push`

将本地分支的更改上传到远程存储库。

#### `git remote`

列出为本地存储库配置的远程存储库名称。

#### `git remote -v`

显示与本地存储库关联的远程存储库 URL，显示获取和推送 URL。

#### `git remote add <name> <url>`

为本地存储库配置添加一个具有指定名称和 URL 的新远程存储库。

#### `git remote remove <name>`

删除本地 git 配置中的特定远程存储库连接。

#### `git remote rename <old_name> <new_name>`

更改本地 git 配置中现有远程存储库连接的名称。

#### `git remote set-url <name> <newurl>`

更改本地 git 配置中现有远程存储库连接的 URL。

#### `git fetch <remote>`

从指定的远程存储库检索最新更改，更新本地远程分支副本而不合并到本地分支。

#### `git pull <remote>`

从指定的远程存储库获取更改并合并到当前分支。

#### `git remote update`

获取存储库跟踪的所有远程更新。

#### `git push <remote> <branch>`

将本地存储库的指定分支上传到给定的远程存储库。

#### `git push <remote> --delete <branch>`

从远程存储库删除指定分支。

#### `git remote show <remote>`

显示有关指定远程存储库的详细信息，包括其 URL、获取和推送配置以及它跟踪的分支。

#### `git ls-remote <repository>`

列出指定远程存储库的引用（如分支和标签）及其提交 ID。此命令允许您在不克隆的情况下查看远程存储库中可用的分支和标签。

#### `git push origin <branch> --set-upstream`

将本地主分支 `<branch>` 上传到远程存储库 origin，并设置本地主分支以跟踪远程分支，以便在未来的 git push 和 git pull 命令中默认使用该远程分支。

#### `git remote add upstream <repository>`

向本地存储库添加一个名为 upstream 的新远程，指向指定的 `<repository>`。这通常用于跟踪您分叉的原始存储库，而 origin 通常指的是您自己的分叉。

#### `git fetch upstream`

从上游远程存储库检索更新，更新对该远程分支和标签的本地引用，但不修改工作目录或合并更改。

#### `git pull upstream <branch>`

从上游远程存储的 `<branch>` 获取更新，并将这些更改合并到当前分支中。这通常用于将更改从原始存储库集成到您自己的本地分支中。

#### `git push origin <branch>`

将本地分支 `<branch>` 上传到 origin 远程存储库，使您的分支及其提交在远程上可用。

## 06. 修改提交

修改 Git 提交使您能够更改最近的提交，通常是为了更正或更新其内容或消息。这可以通过 git commit --amend 命令实现，该命令在默认文本编辑器中打开提交以进行更改。修改特别适用于修复小错误或添加被遗忘的更改，而无需创建新提交，从而导致更简洁更准确的提交历史。

#### `git commit --amend`

修改最新的提交，合并已暂存的更改。

#### `git commit --amend -m "new message"`

修改最近提交的提交消息。

#### `git commit --fixup=HEAD`

使用 `--fixup` 选项创建一个新提交，该选项旨在修正或修改最近的提交（HEAD）。新提交在提交消息中被标记为 fixup!，将在交互式变基中自动修复或修改指定的提交。

## 07. 临时储藏

Git 临时储藏是一项功能，允许您暂时保存尚未准备提交的工作目录更改。通过使用 git stash 命令，您可以将这些更改储藏起来，并将工作目录还原到干净状态，使您能够切换分支或执行其他任务而不会丢失进度。稍后，您可以使用 git stash apply 或 git stash pop 重新应用储藏的更改，使您能够从中断的地方继续。这种功能对于在您需要解决紧急问题或尝试不同代码路径时管理工作进度特别有用。

#### `git stash`

#### `git stash save`

临时保存未提交的更改，使您能够切换分支或执行其他操作，而无需提交不完整的工作。

#### `git stash -m "message"`

#### `git stash save "message"`

与上述相同，但使用消息储藏更改。

#### `git stash show`

显示最新储藏条目的更改摘要，展示哪些文件被修改。

#### `git stash list`

查看存储库中的所有储藏更改，以编号列表显示。

#### `git stash pop`

应用最近的储藏内容，然后立即从储藏列表中删除它。

#### `git stash drop`

从储藏列表中删除最近的储藏条目，而无需应用到工作目录中。

#### `git stash apply`

将最近储藏的更改重新应用到工作目录，而不将其从储藏列表中移除。

#### `git stash clear`

清除所有储藏条目，永久删除储藏列表中的所有保存更改。

#### `git stash branch <branch>`

从您储藏更改之前的提交中创建一个名为 `<branch>` 的新分支，然后将储藏更改应用到该新分支。此命令有效地允许您在单独的分支上继续处理储藏的更改，同时保留原始上下文和更改。

## 08. 标记

Git 标记是一项功能，允许您通过有意义的名称标记存储库历史中的特定点，通常用于版本发布或重要里程碑。与分支不同，标签通常是不可变的，不会更改，为特定提交提供永久引用。在 Git 中有两种类型的标签：轻量标签，它是指向提交的简单指针；注解标签，它存储其他元数据，如标签制作者的姓名、电子邮件、日期和消息。标签可以轻松创建、列出、推送到远程存储库，并删除，提供了一种便捷的方式来管理和引用项目开发时间线中的关键点。

#### `git tag <tag_name>`

创建一个具有指定名称的新标签，指向当前提交（通常用于标记提交历史中的特定点，如版本发布）。

#### `git tag -a <tag_name> -m "message"`

创建具有指定名称和消息的注解标签，其中包含额外的元数据，如标签制作者的姓名、电子邮件和日期，并指向当前提交。

#### `git tag -d <tag_name>`

从本地存储库删除指定的标签。

#### `git tag -f <tag> <commit>`

强制标签指向不同的提交。

#### `git show <tag_name>`

显示指定标签的详细信息，包括其指向的提交及任何相关标签消息或注释。

#### `git push origin <tag_name>`

将指定标签上传到远程存储库，使其在其他人可以使用。

#### `git push origin --tags`

将所有本地标签推送到远程存储库，确保与远程同步所有标签。

#### `git push --follow-tags`

同时推送提交和标签。

#### `git fetch --tags`

从默认远程存储库检索所有标签并将其更新到本地存储库，不影响当前分支。

## 09. 还原更改

还原 Git 中的更改涉及撤销对存储库历史所做的修改。这可以通过多个命令完成，例如 git revert，它会创建一个与指定的先前提交相反的新提交，有效地反转其效果，同时保留提交历史。另一种方法是使用 git reset，它将当前 HEAD 更改为指定提交，并可以根据所选选项（--soft、--mixed、--hard）更新暂存区和工作目录。此外，git checkout 可用于放弃工作目录中的更改，将文件恢复到最后的提交状态。这些工具提供了管理和纠正更改的灵活性，确保存储库保持准确和整洁。

#### `git checkout -- <file>`

放弃工作目录中指定文件的更改，将其还原到最后提交的状态，有效地撤销任何尚未暂存的修改。

#### `git revert <commit>`

创建一个新提交，撤销指定提交中的更改，有效地反转其效果，同时保留历史。

#### `git revert -n <commit>`

还原提交但不提交结果。

#### `git reset`

将当前 HEAD 重置为指定状态，并根据所用选项（--soft、--mixed、--hard）可选地更新暂存区和工作目录。

#### `git reset --soft <commit>`

将 HEAD 移动到指定提交，同时保持索引（暂存区）和工作目录不变，因此在指定提交后所有更改都保持暂存，可以再次提交。这在您想撤销提交但保留更改以备再次提交时有用。

#### `git reset --mixed <commit>`

将 HEAD 移动到指定提交，并更新索引（暂存区）以匹配该提交，但工作目录不变，因此在指定提交后的更改被保留但未跟踪。

#### `git reset --hard <commit>`

将 HEAD 移动到指定提交，并更新索引（暂存区）和工作目录以匹配该提交，同时丢弃指定提交后的所有更改和未跟踪文件。

## 10. 查看历史日志

Git 历史是指在一段时间内对存储库所做的所有更改的记录。它包括一个按照时间顺序排列的提交序列，每个提交代表存储库在特定时刻的快照。这一记录允许开发人员跟踪修改，理解代码库的演变，并通过提供谁进行了更改、何时以及为何进行更改的详细日志来有效地协作。像 git log 这样的工具有助于浏览这一历史，为开发过程中的调试和项目管理提供见解。

#### `git log`

显示提交日志。

#### `git log --oneline`

以单行显示提交摘要。

#### `git log --graph`

显示提交历史的图形表示。

#### `git log --stat`

显示提交历史及文件统计信息。

#### `git log --pretty=format:"%h %s"`

根据指定格式设置日志输出格式。

#### `git log --pretty=format:"%h - %an, %ar : %s"`

提供更人性化的日志格式。

#### `git log --author=<author>`

显示指定作者的提交。

#### `git log --before=<date>`

显示指定日期前的提交。

#### `git log --after=<date>`

#### `git log --since=<date>`

显示指定日期后的提交。

#### `git log --cherry-pick`

省略在两个分支之间等效的提交。

#### `git log --follow <file>`

展示文件的提交，包含重命名。

#### `git log --show-signature`

显示提交的 GPG 签名信息。

#### `git shortlog`

按作者总结 git log 输出。

#### `git shortlog -sn`

按作者总结 git log 输出，并附带提交计数。

#### `git log --simplify-by-decoration`

仅显示由标签或分支引用的提交。

#### `git log --no-merges`

从日志中省略合并提交。

#### `git whatchanged`

以类似于提交日志的格式列出提交数据。

#### `git diff-tree --pretty --name-only --root <commit>`

显示提交树的详细信息。

#### `git log --first-parent`

仅显示当前分支的提交，排除来自其他分支的合并。

## 11. 不同版本间的差异

Git 差异是 Git 中的一项功能，允许您查看存储库中不同状态之间的差异。这可以包括工作目录与暂存区之间的差异、暂存区与最后一次提交之间的差异，或者任何两个提交或分支之间的差异。通过显示文件逐行更改，差异帮助您在提交、合并或应用更改之前进行审核，从而确保代码库的准确性和一致性。

#### `git diff`

显示存储库中不同状态之间的差异，例如工作目录与索引（暂存区）之间、索引与最后一次提交之间，或者两个提交之间的差异。它会展示文件的逐行变化，帮助您在提交或合并前进行审核。

#### `git diff --stat`

显示工作目录与索引（暂存区）之间更改的摘要，帮助您查看哪些文件已被修改以及添加或删除了多少行。

#### `git diff --stat <commit>`

查看提交与工作目录之间的更改。

#### `git diff --stat <commit1> <commit2>`

提供两个提交之间更改的摘要，显示哪些文件被修改以及它们之间改变的数量。

#### `git diff --stat <branch1> <branch2>`

总结两个分支之间的差异，指明文件的更改及更改的幅度。

#### `git diff --name-only <commit>`

仅显示指定提交中修改过的文件名。

#### `git diff --cached`

显示暂存的更改（索引）与最后一次提交之间的差异，帮助您查看将包含在下一次提交中的内容。

#### `git diff HEAD`

显示工作目录与最新一次提交（HEAD）之间的差异，让您查看自上次提交以来的更改。

#### `git diff <branch1> <branch2>`

显示两个分支的尖端之间的差异，突出显示每个分支末端的提交之间的变化。

#### `git difftool`

启动一个差异工具以比较更改。

#### `git difftool <commit1> <commit2>`

使用差异工具显示两个指定提交之间的差异。

#### `git difftool <branch1> <branch2>`

打开差异工具以比较两个分支间的变化。

#### `git cherry <branch>`

比较当前分支与另一个分支之间的提交，并显示每个分支独有的提交。它通常用于识别一个分支中哪些提交尚未应用于另一个分支。

## 12. Git Flow

Git Flow 是一套为 Git 设计的分支模型，为管理更大项目提供了一个强健的框架。它定义了围绕项目发布周期设计的严格分支策略，具有两个主分支（main 和 develop）以及用于功能、发布和修复的支持分支。这种模型有助于组织工作，确保干净且可管理的历史，并通过明确划定不同类型开发工作的角色和流程来促进协作。

#### `git flow init`

初始化一个 git-flow 分支模型的存储库。

#### `git flow feature start <feature>`

在 git-flow 中开始一个新的功能分支。

#### `git flow feature finish <feature>`

在 git-flow 中完成一个功能分支。

## 13. 探索 Git 引用

Git 引用，通常称为 refs，是 Git 存储库中指向特定提交或对象的指针。这些可以是分支、标签和其他引用，如 HEAD，它指向工作目录中签出的当前提交。引用用于跟踪存储库的结构和历史，使 Git 能够高效管理和导航项目时间线的不同点。它们提供了一种命名特定提交的方法，使得更易于操作和修改存储库的历史。

#### `git show-ref --heads`

列出所有头（分支）的引用。

#### `git show-ref --tags`

列出所有标签的引用。

## 14. 配置

Git 配置涉及设置控制 Git 环境行为的各种选项和偏好。这可以包括指定您的用户名和电子邮件、设置默认文本编辑器、为常用命令创建别名以及配置全局忽略文件。配置设置可应用于不同级别：全局（影响您系统上的所有存储库）、本地（影响单个存储库）和系统级别。这些设置确保一个定制且一致的用户体验，简化工作流程并提高版本控制操作的整体效率。

#### `git config --global user.name "Your Name"`

设置全局级别的用户名。

#### `git config --global user.email "your_email@example.com"`

设置全局级别的用户电子邮件。

#### `git config --global core.editor <editor>`

设置默认文本编辑器。

#### `git config --global core.excludesfile <file>`

设置全局忽略文件。

#### `git config --list`

列出所有配置设置。

#### `git config --list --show-origin`

列出所有配置变量，显示其来源。

#### `git config <key>`

检索指定键的值。

#### `git config --get <key>`

检索指定配置键的值。

#### `git config --unset <key>`

移除指定配置键。

#### `git config --global --unset <key>`

全局移除指定配置键。

## 15. 安全

Git GPG 安全涉及使用 GNU Privacy Guard (GPG) 来签署提交和标签，以确保其真实性和完整性。通过配置 GPG 密钥并启用自动签名，开发人员可以验证提交和标签来自可信来源，防止篡改并确保存储库历史的完整性。这种做法通过提供加密保证的变化来源于合法的贡献者来增强安全性。

#### `git config --global user.signingKey <key>`

配置用于签署提交和标签的 GPG 密钥。

#### `git config --global commit.gpgSign true`

自动使用 GPG 签署所有提交。

## 16. 设置别名

Git 别名是自定义快捷方式，您可以创建以简化和加速工作流程，将较长的 Git 命令映射为较短且难忘的名称。通过在 Git 设置中配置别名，您可以以较少的输入快速执行频繁使用的命令。这不仅提高了生产力，还减少了错误的可能性。例如，您可以设置一个别名 git st 以替代 git status，或者将 git co 设置为替代 git checkout。别名可以在全局范围内定义以影响所有存储库，也可以在本地为单个项目定义，提供在精简 Git 操作时的灵活性。

#### `git config --global alias.ci commit`

将 git ci 设置为 git commit 的别名。

#### `git config --global alias.st status`

将 git st 设置为 git status 的别名。

#### `git config --global alias.co checkout`

将 git co 设置为 git checkout 的别名。

#### `git config --global alias.br branch`

将 git br 设置为 git branch 的别名。

#### `git config --global alias.graph "log --graph --all --oneline --decorate"`

为存储库历史的详细图形创建一个别名。

## 17. 变基

Git 变基将您的更改重新应用在另一个分支的历史上，创建更干净且更线性的项目历史。在实践中，有助于通过避免不必要的合并提交来平滑整合更新，确保提交序列简洁明了，使得理解项目的发展更为简单。

#### `git rebase <branch>`

git rebase 命令用于重新应用提交到另一个基础尖端。它允许您将提交序列移动或合并到一个新基础提交。通常用于：

1.  保持线性的项目历史。
2.  将一个分支的更改整合到另一个分支。
3.  使用来自主分支的最新更改更新功能分支。

基本用法是 git rebase `<branch>`，这将重新定位当前分支到指定分支之上。

#### `git rebase --interactive <branch>`

启动交互式变基会话，允许您修改从 `<base>` 开始直到当前 HEAD 的提交。这使您可以重新排序、合并、编辑或删除提交，在推送更改之前提供一种清理和完善提交历史的方法。简写版本：`git rebase -i <branch>`

#### `git rebase --continue`

解决冲突后继续变基过程。

#### `git rebase --abort`

中止变基过程并返回原始分支。

#### `git fetch --rebase`

从远程存储库获取并将本地更改应用到顶部。

## 18. 选择性提取（Cherry-Picking）

Git 选择性提取是一种允许您从一个分支中将特定提交引入另一个分支的过程。这在您希望选择性地将各个更改纳入不同分支而不合并整个分支时特别有用。通过使用 git cherry-pick 命令，您可以隔离并集成所需的提交，确保特定修改包含在当前分支中，同时避免来自分支其他部分的潜在冲突和不希望的更改。

#### `git cherry-pick <commit>`

应用现有提交引入的更改。

#### `git cherry-pick --continue`

解决冲突后继续进行选择性提取。

#### `git cherry-pick --abort`

中止选择性提取过程。

#### `git cherry-pick --no-commit <commit>`

选择性提取提交但不自动提交，并允许进行进一步更改。简写版本：`git cherry-pick -n <commit>`

## 19. 补丁

Git 补丁是一种用于将更改从一个存储库应用到另一个存储库或在同一存储库内从一个分支到另一个分支的方法。它涉及创建补丁文件，这些文本文件代表提交或分支之间的差异。这些补丁文件可以使用类似 git apply 或 git am 的命令应用到存储库中，允许更改在不直接合并分支的情况下进行转移和集成。打补丁对于在不同代码库之间共享特定更改或更新特别有用，确保只有预期的修改被应用。

#### `git apply <patch_file>`

从补丁文件中应用更改到工作目录。

#### `git apply --check`

检查补丁是否可以干净应用。

#### `git format-patch <since_commit>`

为每个自指定提交以来的提交创建补丁文件。

#### `git am <patch_file>`

从电子邮件箱中应用补丁。

#### `git am --continue`

解决冲突后继续应用补丁。

#### `git am --abort`

中止补丁应用过程。

#### `git diff > <file.patch>`

从差异中创建一个补丁文件。

## 20. 相对日期

Git 相对日期允许用户使用人性化的时间表达方式来引用存储库历史中的特定点。例如，像 main@{1.week.ago} 或 [\@3.days.ago]{.citation cites="3.days.ago"} 的命令使您能够访问分支的状态或查看自特定时间段以来的更改。此功能通过使用"昨天"、"2 周前"或特定日期等直观术语来简化浏览存储库的时间线，使您更容易跟踪和管理代码库的演变，而不必记住确切的提交哈希或时间戳。

#### `git show main@{1.week.ago}`

查看一周前您的 main 分支的状态：

#### `git diff @{3.days.ago}`

查看最近 3 天内所做的更改：

#### `git checkout main@{2.weeks.ago}`

检出您的存储库为 2 周前的状态：

#### `git log @{1.month.ago}..HEAD`

查看从 1 个月前到现在的提交日志。

#### `@{2024-06-01}`

#### `@{yesterday}`

#### `@{"1 week 2 days ago"}`

其他用法示例。

## 21. 注释（Blaming）

Git 注释功能是 Git 中的一项功能，它识别对文件每行所做的最新修改，将更改归因于特定提交和作者。通过使用 git blame 命令，它提供详细的文件注释，显示谁进行了更改以及何时更改。此工具对于跟踪文件历史、理解代码演变和识别错误或变更的来源特别有用。通过精确定位每行的负责任提交和作者，开发人员可以获得对开发过程的洞察，并促进更好的团队内部协作和责任分配。

#### `git blame <file>`

显示文件每行的最新修改。

#### `git blame <file> -L <start>,<end>`

限制注释输出到指定的行范围。

#### `git blame <file> <commit>`

显示直到指定提交的注释信息。

#### `git blame <file> -C -C`

显示哪个修订和作者最后修改了文件的每一行，检测复制。

`-C` 选项检测在同一文件中移动或复制的行。使用一次（`-C`）会检测在同一文件中移动或复制的行。使用 `-C` 选项两次（`-C -C`）会让 git 查找未修改的文件作为复制源候选。这意味着不仅会尝试在同一文件中找到复制行的来源，还会在其他文件中查找。

#### `git blame <file> --reverse`

反向工作，显示最后更改指定文件每一行的责任人。

#### `git blame <file> --first-parent`

显示文件中最近一次修改的责任人，只遵循合并更改的第一个父提交。

## 22. 归档

Git 归档是一项允许您创建归档文件（如 .tar 或 .zip）的功能，其中包含特定提交、分支或标签的内容。这对于在特定时间点获取存储库快照非常有用，使您能够分发或备份存储库的状态，而无需包含整个 Git 历史。通常使用 git archive 命令来实现这一目的，为将项目的当前状态导出到便携格式提供了便利。

#### `git archive <format> <tree-ish>`

创建一个包含指定 tree-ish（如提交、分支或标签）在给定格式中的内容的归档文件（例如 .tar 或 .zip 文件）。例如：

`git archive --format=tar HEAD` 创建当前提交（HEAD）的 .tar 归档。

`git archive --format=zip v1.0` 创建 v1.0 标签中文件的 .zip 归档。

此命令对于在特定时间点打包存储库的快照很有用。

## 23. 跟踪

Git 跟踪是指监视和管理存储库中文件的过程。命令 git ls-files 列出 Git 正在跟踪的所有文件，提供当前受版本控制的文件的明确视图。另一方面，git ls-tree `<branch>` 会显示指定分支的树对象的内容，显示该存储库此时的结构和文件。这两个命令共同帮助开发人员理解哪些文件被包含在存储库中以及它们是如何组织的，确保有效地跟踪和管理项目的代码库。

#### `git ls-files`

列出所有被跟踪的文件。

#### `git ls-tree <branch>`

列出树对象的内容。

## 24. 索引操作

Git 索引操作涉及管理用于提交前准备更改的暂存区（也称为索引）。这可能包括将文件标记为"假定未更改"，以暂时忽略更改，或者重置这些标记以再次跟踪更改。索引操作命令，如 git update-index，允许您控制哪些文件将包含在下一个提交中，为特定任务提供了处理更改和优化工作流程的灵活性。

#### `git update-index --assume-unchanged <file>`

将文件标记为假定未更改。

#### `git update-index --no-assume-unchanged <file>`

取消将文件标记为假定未更改。

## 25. 合并提交

Git 合并提交是指将多个提交合并为一个提交的过程。这通常在合并更改到主分支之前完成，使得历史更为简洁且易于阅读。可以使用交互式变基命令（git rebase -i）来进行合并提交，这允许开发人员选择性地合并、重新排序或编辑提交。通过合并提交，可以将多余或细微的更改整合，呈现更清晰的开发过程叙述。

#### `git rebase -i HEAD~<n>`

交互式合并提交。

## 26. 数据完整性

Git 数据完整性是指 Git 用来确保存储库内数据准确性和一致性的机制和过程。Git 使用加密哈希（SHA-1 或 SHA-256）来唯一标识对象，例如提交、树和 blob。这种哈希不仅为每个对象提供唯一标识符，还确保对象内容的任何更改都会导致不同的哈希，从而检测到任何损坏或篡改。像 git fsck 这样的命令可以用于验证数据库中对象的连通性和有效性，确保存储库的整体健康和完整性。

#### `git fsck`

验证数据库中对象的连通性和有效性。

#### `git fsck --unreachable`

查找存储库中无法从任何引用访问的对象。

#### `git prune`

移除不可到达的对象。

#### `git gc`

运行垃圾收集过程。

Git 垃圾收集是一种维护过程，通过删除不必要的文件和压缩文件修订以节省空间来清理和优化存储库。通过 git gc 命令触发的此过程，整合和删除不可达到的对象（如孤立提交和无引用的 blob），确保存储库保持高效和高性能。定期进行垃圾收集有助于有效管理存储并保持存储库结构的组织性。

## 27. 清理

Git 中的清理涉及到删除不再需要的不必要文件、引用和分支。这有助于保持存储库的组织性和高效性。定期清理活动，如修剪远程跟踪分支、删除未跟踪文件和移除陈旧引用，确保存储库保持可管理性并免于杂乱。在实践中，这些操作可以提高性能、减少存储需求并使得在项目中导航和工作变得更容易。

#### `git fetch --prune`

移除远程中不再存在的引用。

#### `git remote prune <name>`

修剪所有过时的远程跟踪分支。

#### `git fetch origin --prune`

清理远程存储库中的陈旧引用。

#### `git clean -f`

从工作目录中移除未跟踪的文件，强制删除 Git 未跟踪的文件。

#### `git clean -fd`

从工作目录中移除未跟踪的文件和目录，包括 Git 未跟踪的任何文件和目录。

#### `git clean -i`

进入清理未跟踪文件的交互模式。

#### `git clean -X`

仅移除工作目录中的忽略文件。

## 28. 子树

Git 子树是一种将子项目纳入主存储库的方法。与子模块不同，子模块将子项目视为具有自己存储库的独立实体，子树允许您直接在主存储库的子目录中包括另一个存储库的内容。这种方法通过消除多重存储库的需要并使子项目的无缝集成、合并和获取更新变得简单化，从而简化工作流程。子树提供了一种灵活便捷的方式来管理依赖项和协作需要合并外部代码库的项目。

#### `git subtree add --prefix=<dir> <repository> <branch>`

将存储库添加为子树。

#### `git subtree merge --prefix=<dir> <branch>`

合并子树。

#### `git subtree pull --prefix=<dir> <repository> <branch>`

从子树存储库中获取新更改。

## 29. 搜索

git grep 是 Git 中一个强大的搜索命令，允许用户在存储库文件中搜索特定字符串或模式。它搜索工作目录和索引，提供一种快速高效的方法来在多个文件中定位指定模式的出现。此命令对希望查找项目中的代码、注释或文本的开发人员特别有用，使他们能够轻松导航和理解大型代码库。通过各种选项和标志，git grep 可以执行目标搜索，使其成为代码分析和维护的重要工具。

#### `git grep <pattern>`

在工作目录和索引中搜索字符串。

#### `git grep -e <pattern>`

搜索特定模式。

## 30. 二分查找

Git 二分查找是一个强大的调试工具，有助于识别项目中引入错误或问题的特定提交。通过在提交历史中执行二分搜索，git bisect 高效地缩小潜在问题提交的范围。该过程涉及标记一个已知的良好提交和一个已知的不良提交，然后反复测试中间提交以确定它们是良好还是不良。通过这种迭代方法，迅速隔离故障提交，使开发人员能够精准定位导致问题的具体更改，从而加快调试速度并提高准确性。

#### `git bisect start`

启动二分查找会话。

#### `git bisect bad`

标记当前版本为不良。

#### `git bisect good <commit>`

标记指定提交为良好。

#### `git bisect reset`

结束二分查找会话并返回原始分支。

#### `git bisect visualize`

启动一个可视化工具以辅助二分查找。

## 31. 属性

Git 属性是定义 Git 如何处理存储库中特定文件或路径的设置。这些属性是在名为 .gitattributes 的文件中定义的，可以控制文本编码、行尾正则化、合并策略和差异算法等各种行为。通过设置属性，您可以确保在不同环境和协作者之间保持一致行为，使其更易于管理具有特殊需求或复杂性的文件。例如，您可以将某些文件标记为二进制文件，以防止 Git 尝试合并它们，或指定自定义差异驱动程序以获得更有意义的比较。

#### `git check-attr <attribute> -- <file>`

显示 .gitattributes 配置中为给定文件定义的特定属性的值，帮助您了解 Git 如何处理文件的属性，如文本编码、合并行为或差异处理。

## 32. 检出

git checkout 是 Git 中一个多功能命令，用于在存储库中切换不同的分支、标签或提交。通过更新工作目录和索引以匹配指定的分支或提交，它使您能够查看或处理存储库在该点的状态。此外，git checkout 可用于创建新分支、从提交中恢复特定文件，甚至使用 --orphan 选项启动一个无历史的新分支。此命令对于浏览和管理项目代码库的不同版本至关重要。

#### `git checkout <commit>`

更新工作目录和索引以匹配指定提交，使查看或处理存储库在该提交的状态成为可能，但处于"分离的 HEAD"状态，意味着您不在任何分支上。

#### `git checkout -b <branch> <commit>`

从指定提交开始创建并切换到名为 `<branch>` 的新分支，使您能够从提交历史的该点开始工作。

#### `git checkout <commit> -- <file>`

从特定提交中恢复指定文件到您的工作目录，用该提交中的版本替换文件的当前版本，而不更改提交历史或索引。

#### `git checkout --orphan <new_branch>`

创建一个名为 `<new_branch>` 的无提交历史的新分支，有效地开始一个具有干净工作目录和索引的新分支，犹如它是一个新存储库。

## 33. 引用日志（Reflog）

Git 引用日志是一个强大的工具，记录对 Git 存储库中分支和 HEAD 引用的头所做的所有更改。这包括诸如提交、检出、合并和重置等操作。通过维护对这些更改的历史记录，引用日志允许用户跟踪最近的修改并恢复丢失的提交，即使它们不是当前分支历史的一部分。它提供了一种浏览存储库状态变化的方法，使其成为调试和撤销错误的重要资源。

#### `git reflog`

显示对 HEAD 引用和分支提示的所有更改的日志，包括提交、检出、合并和重置，使您能够恢复丢失的提交或跟踪存储库最新的状态更改。

#### `git reflog show <ref>`

显示对指定引用（`<ref>`）的引用日志，显示对该引用的变化日志，包括对 HEAD 或分支提示的更新，以及相关的提交消息和时间戳。

## 34. 处理未跟踪文件

#### `git clean`

从工作目录中删除未跟踪文件和目录。默认情况下，只显示哪些文件将被删除而不实际删除任何东西。要执行实际清理，您需要使用附加标志：

-   `git clean -f`: 移除未跟踪的文件。
-   `git clean -fd`: 移除未跟踪的文件和目录。
-   `git clean -fx`: 移除未跟踪的文件，包括 .gitignore 忽略的文件。
-   `git clean -n`: 显示将被移除的文件，而不实际删除它们。

## 35. 强制推送

#### `git push --force`

强制推送您的本地分支到远程存储库，即使会导致非快进合并。这会用您的本地更改覆盖远程分支。当您的历史被重写（例如，使用变基）并需要更新远程分支以匹配您的本地分支时，这可能是必要的，但也有可能覆盖其他人的更改，因此应谨慎使用。

## 36. 获取与拉取

#### `git fetch --all`

从配置为本地存储库的所有远程存储库中检索更新，获取所有分支和标签的更改而不修改您的本地分支。

#### `git pull --rebase`

从远程存储库获取更改并重演您本地提交到更新后的远程分支，而不是合并它们。这保持提交历史线性并避免不必要的合并提交。

## 37. 处理合并冲突

处理 Git 中的合并冲突是多贡献者项目协作的重要技能。当不同分支或提交中的更改重叠或矛盾时，会发生合并冲突，无法自动合并。解决这些冲突涉及审查并手动调和差异，以确保最终代码准确地整合来自所有方的贡献。在实践中，有效管理合并冲突有助于维护代码的完整性，并通过确保正确纳入每个人的更改来促进平滑合作。

#### `git mergetool`

启动一个合并工具，帮助您解决合并或变基期间出现的冲突。它会打开一个已在 Git 设置中配置的图形界面或基于文本的工具，使您能够手动解决冲突并完成合并。

#### `git rerere`

rerere 是"重用记录的解决"的缩写，是一项通过重用您之前记录过的冲突解决方案，帮助自动在将来的合并或变基中解决冲突的功能。启用后，Git 会记录您如何解决冲突，并且如果再次发生相同的冲突，它可以自动应用相同的解决方案。

## 38. 工作树

Git 工作树允许您拥有与单个存储库关联的多个工作目录。这对于无需在同一目录中不断切换分支的情况下，同时在多个分支上工作特别有用。通过使用工作树，您可以轻松管理不同的功能、错误修复或实验在隔离环境中，提高工作效率并减少冲突的风险。

#### `git worktree add ../new-branch feature-branch`

在一个名为"new-branch"的目录中基于"feature-branch"创建一个新的工作树。

#### `git worktree list`

列出与当前存储库关联的所有工作树，显示其路径及它们检出的分支。

#### `git worktree remove <path>`

移除指定路径下的工作树，删除工作目录并分离分支。

#### `git worktree prune`

移除不存在的工作树的引用，清理工作树列表。

#### `git worktree lock <path>`

锁定指定路径下的工作树，防止其被修剪。

#### `git worktree unlock <path>`

解锁指定路径下的工作树，允许其在必要时被修剪。

## 39. 子模块

Git 子模块是一种在您自己的存储库中包括和管理外部存储库的方法。对于跨多个项目重用代码、维护依赖项或集成第三方库特别有用。通过使用子模块，您可以保持主存储库的清晰和模块化，同时确保包含所有必要组件并进行版本控制。

#### `git submodule init`

初始化存储库中的子模块。此命令设置子模块所需的配置，但实际上并不会克隆它们。

#### `git submodule update`

将子模块克隆并签出到指定路径。通常在 git submodule init 之后运行。

#### `git submodule add <repository> <path>`

在指定路径向存储库中添加一个新子模块，将其链接到指定的存储库。

#### `git submodule status`

显示所有子模块的状态，展示其提交哈希和是否是最新的、修改过的或未初始化的。

#### `git submodule foreach <command>`

在每个子模块中运行指定命令。用于对所有子模块执行批处理操作。

#### `git submodule sync`

同步配置文件中的子模块 URL 与 .gitmodules 文件中的 URL，确保它们是最新的。

#### `git submodule deinit <path>`

取消注册指定子模块，移除其配置。不删除子模块的工作目录。

#### `git submodule update --remote`

获取并更新子模块到来自其远程存储库的最新提交。

#### `git submodule set-url <path> <newurl>`

更改指定子模块的 URL 到新的 URL。

#### `git submodule absorbgitdirs`

将子模块的 Git 目录吸收到超项目中以简化结构。


## 写在最后


谢谢你把时间交给这本手册。

愿每一次 push，都让你的项目和心情，前进一小步。

如果本手册对您有帮助，请告诉他人。

如果过程中遇到任何卡点，请告诉我，我将第一时间回复您。


> “愿你于漫长迭代中，仍保初心热血；
> 
> 愿每一次 push，都把世界改良一寸。”


至此收卷，山高路阔，且以 Git 为剑。
